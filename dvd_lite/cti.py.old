#!/usr/bin/env python3
"""
ëˆ„ë½ëœ í•µì‹¬ ëª¨ë“ˆ íŒŒì¼ë“¤ì„ ìƒì„±í•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸
"""

import os
from pathlib import Path

def create_cti_module():
    """CTI ëª¨ë“ˆ ìƒì„±"""
    content = '''# dvd_lite/cti.py
"""
DVD-Lite CTI ìˆ˜ì§‘ê¸°
ê°„ë‹¨í•œ ìœ„í˜‘ ì •ë³´ ìˆ˜ì§‘ ë° ë‚´ë³´ë‚´ê¸°
"""

import json
import time
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from pathlib import Path

# ThreatIndicatorë¥¼ ì—¬ê¸°ì„œ ì •ì˜
@dataclass
class ThreatIndicator:
    ioc_type: str
    value: str
    confidence: int
    attack_type: str
    timestamp: datetime
    source: str = "dvd-lite"

# =============================================================================
# ê°„ë‹¨í•œ CTI ìˆ˜ì§‘ê¸°
# =============================================================================

class SimpleCTI:
    """ê°„ë‹¨í•œ CTI ìˆ˜ì§‘ê¸°"""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {"confidence_threshold": 60, "export_format": "json"}
        self.indicators = []
        self.attack_patterns = {}
        self.statistics = {
            "total_indicators": 0,
            "by_attack_type": {},
            "by_confidence": {"high": 0, "medium": 0, "low": 0},
            "last_update": None
        }
    
    async def collect_from_result(self, attack_result):
        """ê³µê²© ê²°ê³¼ì—ì„œ CTI ìˆ˜ì§‘"""
        # IOCì—ì„œ ìœ„í˜‘ ì§€í‘œ ìƒì„±
        for ioc in attack_result.iocs:
            indicator = self._create_indicator(ioc, attack_result)
            if indicator:
                self.indicators.append(indicator)
        
        # ê³µê²© íŒ¨í„´ ì €ì¥
        pattern_id = f"{attack_result.attack_type.value}_{attack_result.attack_name}"
        self.attack_patterns[pattern_id] = {
            "attack_name": attack_result.attack_name,
            "attack_type": attack_result.attack_type.value,
            "success_rate": attack_result.success_rate,
            "avg_response_time": attack_result.response_time,
            "last_seen": datetime.fromtimestamp(attack_result.timestamp).isoformat(),
            "ioc_count": len(attack_result.iocs)
        }
        
        # í†µê³„ ì—…ë°ì´íŠ¸
        self._update_statistics()
    
    def _create_indicator(self, ioc: str, attack_result) -> Optional[ThreatIndicator]:
        """IOCì—ì„œ ìœ„í˜‘ ì§€í‘œ ìƒì„±"""
        try:
            # IOC íŒŒì‹±
            if ":" in ioc:
                ioc_type, value = ioc.split(":", 1)
            else:
                ioc_type = "unknown"
                value = ioc
            
            # ì‹ ë¢°ë„ ê³„ì‚°
            confidence = self._calculate_confidence(ioc_type, attack_result)
            
            # ìµœì†Œ ì‹ ë¢°ë„ í™•ì¸
            if confidence < self.config["confidence_threshold"]:
                return None
            
            indicator = ThreatIndicator(
                ioc_type=ioc_type.lower(),
                value=value,
                confidence=confidence,
                attack_type=attack_result.attack_type.value,
                timestamp=datetime.fromtimestamp(attack_result.timestamp),
                source="dvd-lite"
            )
            
            return indicator
            
        except Exception:
            return None
    
    def _calculate_confidence(self, ioc_type: str, attack_result) -> int:
        """IOC ì‹ ë¢°ë„ ê³„ì‚°"""
        base_confidence = 70
        
        # ê³µê²© ì„±ê³µ ì—¬ë¶€ì— ë”°ë¥¸ ì¡°ì •
        if attack_result.status.value == "success":
            confidence_modifier = 15
        elif attack_result.status.value == "detected":
            confidence_modifier = 10
        else:
            confidence_modifier = -20
        
        # IOC íƒ€ì…ë³„ ì¡°ì •
        type_modifiers = {
            "mavlink_msg": 10,
            "mavlink_host": 15,
            "command_injected": 20,
            "fake_gps": 25,
            "waypoint_injected": 18,
            "log_extracted": 12,
            "param_extracted": 10
        }
        
        type_modifier = type_modifiers.get(ioc_type, 0)
        
        final_confidence = base_confidence + confidence_modifier + type_modifier
        return max(10, min(100, final_confidence))
    
    def _update_statistics(self):
        """í†µê³„ ì—…ë°ì´íŠ¸"""
        self.statistics["total_indicators"] = len(self.indicators)
        self.statistics["last_update"] = datetime.now().isoformat()
        
        # ê³µê²© íƒ€ì…ë³„ í†µê³„
        type_counts = {}
        confidence_counts = {"high": 0, "medium": 0, "low": 0}
        
        for indicator in self.indicators:
            # ê³µê²© íƒ€ì…ë³„
            attack_type = indicator.attack_type
            type_counts[attack_type] = type_counts.get(attack_type, 0) + 1
            
            # ì‹ ë¢°ë„ë³„
            if indicator.confidence >= 80:
                confidence_counts["high"] += 1
            elif indicator.confidence >= 60:
                confidence_counts["medium"] += 1
            else:
                confidence_counts["low"] += 1
        
        self.statistics["by_attack_type"] = type_counts
        self.statistics["by_confidence"] = confidence_counts
    
    def get_summary(self) -> Dict[str, Any]:
        """ìœ„í˜‘ ì •ë³´ ìš”ì•½"""
        return {
            "total_indicators": len(self.indicators),
            "total_patterns": len(self.attack_patterns),
            "statistics": self.statistics,
            "recent_indicators": [
                {
                    "type": ind.ioc_type,
                    "value": ind.value[:50] + "..." if len(ind.value) > 50 else ind.value,
                    "confidence": ind.confidence,
                    "attack_type": ind.attack_type
                }
                for ind in sorted(self.indicators, key=lambda x: x.timestamp, reverse=True)[:5]
            ]
        }
    
    def export_json(self, filename: str = None) -> str:
        """JSON í˜•ì‹ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°"""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"results/cti_data_{timestamp}.json"
        
        # ê²°ê³¼ ë””ë ‰í† ë¦¬ ìƒì„±
        Path(filename).parent.mkdir(parents=True, exist_ok=True)
        
        # ë‚´ë³´ë‚¼ ë°ì´í„° êµ¬ì„±
        export_data = {
            "metadata": {
                "export_time": datetime.now().isoformat(),
                "total_indicators": len(self.indicators),
                "total_patterns": len(self.attack_patterns),
                "source": "dvd-lite"
            },
            "statistics": self.statistics,
            "indicators": [
                {
                    "ioc_type": ind.ioc_type,
                    "value": ind.value,
                    "confidence": ind.confidence,
                    "attack_type": ind.attack_type,
                    "timestamp": ind.timestamp.isoformat(),
                    "source": ind.source
                }
                for ind in self.indicators
            ],
            "attack_patterns": self.attack_patterns
        }
        
        # JSON íŒŒì¼ë¡œ ì €ì¥
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)
        
        return filename
    
    def export_csv(self, filename: str = None) -> str:
        """CSV í˜•ì‹ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°"""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"results/cti_indicators_{timestamp}.csv"
        
        # ê²°ê³¼ ë””ë ‰í† ë¦¬ ìƒì„±
        Path(filename).parent.mkdir(parents=True, exist_ok=True)
        
        # CSV ë‚´ìš© ìƒì„±
        csv_lines = [
            "IOC_Type,Value,Confidence,Attack_Type,Timestamp,Source"
        ]
        
        for ind in self.indicators:
            line = f"{ind.ioc_type},{ind.value},{ind.confidence},{ind.attack_type},{ind.timestamp.isoformat()},{ind.source}"
            csv_lines.append(line)
        
        # CSV íŒŒì¼ë¡œ ì €ì¥
        with open(filename, 'w', encoding='utf-8') as f:
            f.write('\\n'.join(csv_lines))
        
        return filename
    
    def query_indicators(self, **filters) -> List[ThreatIndicator]:
        """ì§€í‘œ ì¿¼ë¦¬"""
        results = []
        
        for indicator in self.indicators:
            match = True
            
            # í•„í„° ì¡°ê±´ í™•ì¸
            for key, value in filters.items():
                if key == "ioc_type" and indicator.ioc_type != value:
                    match = False
                    break
                elif key == "attack_type" and indicator.attack_type != value:
                    match = False
                    break
                elif key == "min_confidence" and indicator.confidence < value:
                    match = False
                    break
            
            if match:
                results.append(indicator)
        
        return results
    
    def print_summary(self):
        """ìš”ì•½ ì •ë³´ ì¶œë ¥"""
        summary = self.get_summary()
        
        print("\\n" + "="*40)
        print("ğŸ” CTI ìˆ˜ì§‘ ê²°ê³¼ ìš”ì•½")
        print("="*40)
        print(f"ìˆ˜ì§‘ëœ ì§€í‘œ: {summary['total_indicators']}ê°œ")
        print(f"ê³µê²© íŒ¨í„´: {summary['total_patterns']}ê°œ")
        
        if summary["statistics"]["by_attack_type"]:
            print("\\nğŸ“Š ê³µê²© íƒ€ì…ë³„ ë¶„í¬:")
            for attack_type, count in summary["statistics"]["by_attack_type"].items():
                print(f"  - {attack_type}: {count}ê°œ")
        
        print(f"\\nğŸ¯ ì‹ ë¢°ë„ ë¶„í¬:")
        confidence_stats = summary["statistics"]["by_confidence"]
        print(f"  - ë†’ìŒ (80+): {confidence_stats['high']}ê°œ")
        print(f"  - ì¤‘ê°„ (60-79): {confidence_stats['medium']}ê°œ")
        print(f"  - ë‚®ìŒ (<60): {confidence_stats['low']}ê°œ")
        
        if summary["recent_indicators"]:
            print(f"\\nğŸ“‹ ìµœê·¼ ì§€í‘œ (ìµœì‹  5ê°œ):")
            for i, ind in enumerate(summary["recent_indicators"], 1):
                print(f"  {i}. {ind['type']}: {ind['value']} (ì‹ ë¢°ë„: {ind['confidence']})")
        
        print("="*40)
'''
    
    file_path = Path("dvd_lite/cti.py")
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"âœ… ìƒì„±: {file_path}")

def create_attacks_module():
    """ê¸°ë³¸ attacks ëª¨ë“ˆ ìƒì„±"""
    content = '''# dvd_lite/attacks.py
"""
DVD-Lite ê³µê²© ëª¨ë“ˆë“¤
8ê°œ í•µì‹¬ ë“œë¡  ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ êµ¬í˜„
"""

import asyncio
import random
import time
from typing import Tuple, List, Dict, Any

from .main import BaseAttack, AttackType

# =============================================================================
# ì •ì°° ê³µê²©ë“¤
# =============================================================================

class WiFiScan(BaseAttack):
    """WiFi ë„¤íŠ¸ì›Œí¬ ìŠ¤ìº” ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.RECONNAISSANCE
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """WiFi ë„¤íŠ¸ì›Œí¬ ìŠ¤ìº” ì‹¤í–‰"""
        await asyncio.sleep(1.5)  # ìŠ¤ìº” ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜
        
        # ë°œê²¬ëœ ë„¤íŠ¸ì›Œí¬ ì‹œë®¬ë ˆì´ì…˜
        networks = ["Drone_WiFi", "DroneControl", "UAV_Network", "Companion_AP"]
        found_networks = random.sample(networks, k=random.randint(1, 3))
        
        # IOC ìƒì„±
        iocs = [f"SSID:{network}" for network in found_networks]
        
        # íƒ€ê²Ÿ ë„¤íŠ¸ì›Œí¬ ë°œê²¬ ì—¬ë¶€ë¡œ ì„±ê³µ íŒë‹¨
        success = "Drone_WiFi" in found_networks or random.random() > 0.3
        
        details = {
            "found_networks": found_networks,
            "scan_duration": 1.5,
            "success_rate": 0.8 if success else 0.2
        }
        
        return success, iocs, details

class DroneDiscovery(BaseAttack):
    """ë“œë¡  ì‹œìŠ¤í…œ ë°œê²¬ ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.RECONNAISSANCE
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ë„¤íŠ¸ì›Œí¬ì—ì„œ ë“œë¡  ì‹œìŠ¤í…œ ë°œê²¬"""
        await asyncio.sleep(2.0)
        
        # ìŠ¤ìº”ëœ í˜¸ìŠ¤íŠ¸ë“¤
        hosts = [f"10.13.0.{i}" for i in range(2, 6)]
        
        # MAVLink í¬íŠ¸ í™•ì¸ ì‹œë®¬ë ˆì´ì…˜
        mavlink_hosts = []
        for host in hosts:
            if random.random() > 0.6:  # 40% í™•ë¥ ë¡œ MAVLink ë°œê²¬
                mavlink_hosts.append(host)
        
        iocs = [f"MAVLINK_HOST:{host}" for host in mavlink_hosts]
        
        success = len(mavlink_hosts) > 0
        
        details = {
            "scanned_hosts": hosts,
            "mavlink_hosts": mavlink_hosts,
            "open_ports": [14550, 14551] if success else [],
            "success_rate": 0.9 if success else 0.1
        }
        
        return success, iocs, details

class PacketSniff(BaseAttack):
    """íŒ¨í‚· ìŠ¤ë‹ˆí•‘ ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.RECONNAISSANCE
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """MAVLink íŒ¨í‚· ìº¡ì²˜"""
        await asyncio.sleep(3.0)
        
        # ìº¡ì²˜ëœ ë©”ì‹œì§€ ì‹œë®¬ë ˆì´ì…˜
        mavlink_messages = [
            "HEARTBEAT", "GPS_RAW_INT", "ATTITUDE", "GLOBAL_POSITION_INT",
            "MISSION_CURRENT", "RC_CHANNELS", "SERVO_OUTPUT_RAW"
        ]
        
        captured = random.sample(mavlink_messages, k=random.randint(2, 5))
        
        iocs = [f"MAVLINK_MSG:{msg}" for msg in captured]
        
        success = len(captured) >= 3
        
        details = {
            "captured_messages": captured,
            "capture_duration": 3.0,
            "total_packets": random.randint(50, 200),
            "success_rate": 0.7 if success else 0.3
        }
        
        return success, iocs, details

# =============================================================================
# í”„ë¡œí† ì½œ ë³€ì¡° ê³µê²©ë“¤
# =============================================================================

class TelemetrySpoof(BaseAttack):
    """í…”ë ˆë©”íŠ¸ë¦¬ ìŠ¤í‘¸í•‘ ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.PROTOCOL_TAMPERING
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ê°€ì§œ í…”ë ˆë©”íŠ¸ë¦¬ ë°ì´í„° ì£¼ì…"""
        await asyncio.sleep(2.5)
        
        # ìŠ¤í‘¸í•‘í•  ë°ì´í„°
        fake_data = {
            "gps_lat": 37.7749 + random.uniform(-0.01, 0.01),
            "gps_lon": -122.4194 + random.uniform(-0.01, 0.01),
            "altitude": random.randint(50, 150),
            "battery": random.randint(20, 80)
        }
        
        iocs = [
            f"FAKE_GPS:{fake_data['gps_lat']:.6f},{fake_data['gps_lon']:.6f}",
            f"FAKE_ALT:{fake_data['altitude']}",
            f"FAKE_BATTERY:{fake_data['battery']}"
        ]
        
        success = random.random() > 0.4  # 60% ì„±ê³µë¥ 
        
        details = {
            "spoofed_data": fake_data,
            "injection_method": "MAVLink",
            "success_rate": 0.6 if success else 0.0
        }
        
        return success, iocs, details

# =============================================================================
# ì£¼ì… ê³µê²©ë“¤
# =============================================================================

class CommandInject(BaseAttack):
    """ëª…ë ¹ ì£¼ì… ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.INJECTION
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """MAVLink ëª…ë ¹ ì£¼ì…"""
        await asyncio.sleep(1.8)
        
        # ì£¼ì…í•  ëª…ë ¹ë“¤
        commands = ["ARM_DISARM", "SET_MODE", "NAV_LAND", "DO_SET_SERVO"]
        injected_cmd = random.choice(commands)
        
        iocs = [f"COMMAND_INJECTED:{injected_cmd}"]
        
        success = random.random() > 0.5  # 50% ì„±ê³µë¥ 
        
        details = {
            "injected_command": injected_cmd,
            "target_system": 1,
            "target_component": 1,
            "success_rate": 0.5 if success else 0.0
        }
        
        return success, iocs, details

class WaypointInject(BaseAttack):
    """ì›¨ì´í¬ì¸íŠ¸ ì£¼ì… ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.INJECTION
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ì•…ì„± ì›¨ì´í¬ì¸íŠ¸ ì£¼ì…"""
        await asyncio.sleep(2.2)
        
        # ì•…ì„± ì›¨ì´í¬ì¸íŠ¸
        malicious_waypoint = {
            "lat": 37.7749 + random.uniform(-0.1, 0.1),
            "lon": -122.4194 + random.uniform(-0.1, 0.1),
            "alt": random.randint(10, 200)
        }
        
        iocs = [f"WAYPOINT_INJECTED:{malicious_waypoint['lat']:.6f},{malicious_waypoint['lon']:.6f},{malicious_waypoint['alt']}"]
        
        success = random.random() > 0.6  # 40% ì„±ê³µë¥ 
        
        details = {
            "malicious_waypoint": malicious_waypoint,
            "mission_cleared": success,
            "success_rate": 0.4 if success else 0.0
        }
        
        return success, iocs, details

# =============================================================================
# ë°ì´í„° íƒˆì·¨ ê³µê²©ë“¤
# =============================================================================

class LogExtract(BaseAttack):
    """ë¡œê·¸ ì¶”ì¶œ ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.EXFILTRATION
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ë¹„í–‰ ë¡œê·¸ ì¶”ì¶œ"""
        await asyncio.sleep(3.5)
        
        # ì¶”ì¶œ ê°€ëŠ¥í•œ ë¡œê·¸ íŒŒì¼ë“¤
        log_files = [
            "flight_log_001.bin",
            "flight_log_002.bin", 
            "parameters.txt",
            "waypoints.log"
        ]
        
        extracted = random.sample(log_files, k=random.randint(1, 3))
        
        iocs = [f"LOG_EXTRACTED:{log}" for log in extracted]
        
        success = len(extracted) >= 2
        
        details = {
            "extracted_files": extracted,
            "access_method": "FTP",
            "file_sizes": {log: random.randint(1024, 10240) for log in extracted},
            "success_rate": 0.6 if success else 0.2
        }
        
        return success, iocs, details

class ParamExtract(BaseAttack):
    """íŒŒë¼ë¯¸í„° ì¶”ì¶œ ê³µê²©"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.EXFILTRATION
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ì‹œìŠ¤í…œ íŒŒë¼ë¯¸í„° ì¶”ì¶œ"""
        await asyncio.sleep(2.8)
        
        # ì¶”ì¶œëœ íŒŒë¼ë¯¸í„°ë“¤
        parameters = {
            "BATT_CAPACITY": 5000,
            "FENCE_ENABLE": 1,
            "RTL_ALT": 15,
            "COMPASS_CAL": 1,
            "GPS_TYPE": 1
        }
        
        extracted_params = dict(random.sample(list(parameters.items()), k=random.randint(2, 4)))
        
        iocs = [f"PARAM_EXTRACTED:{param}={value}" for param, value in extracted_params.items()]
        
        success = len(extracted_params) >= 3
        
        details = {
            "extracted_parameters": extracted_params,
            "total_available": len(parameters),
            "extraction_method": "MAVLink PARAM_REQUEST",
            "success_rate": 0.7 if success else 0.3
        }
        
        return success, iocs, details

# =============================================================================
# ê³µê²© ëª¨ë“ˆ ë“±ë¡ í•¨ìˆ˜
# =============================================================================

def register_all_attacks(dvd_lite):
    """ëª¨ë“  ê³µê²© ëª¨ë“ˆì„ DVD-Liteì— ë“±ë¡"""
    attacks = {
        "wifi_scan": WiFiScan,
        "drone_discovery": DroneDiscovery,
        "packet_sniff": PacketSniff,
        "telemetry_spoof": TelemetrySpoof,
        "command_inject": CommandInject,
        "waypoint_inject": WaypointInject,
        "log_extract": LogExtract,
        "param_extract": ParamExtract
    }
    
    for name, attack_class in attacks.items():
        dvd_lite.register_attack(name, attack_class)
    
    return list(attacks.keys())
'''
    
    file_path = Path("dvd_lite/attacks.py")
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"âœ… ìƒì„±: {file_path}")

def create_main_module():
    """ë©”ì¸ ëª¨ë“ˆ ì—…ë°ì´íŠ¸"""
    content = '''# dvd_lite/main.py
"""
DVD-Lite ë©”ì¸ í”„ë ˆì„ì›Œí¬
ê²½ëŸ‰í™”ëœ ë“œë¡  ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ë° CTI ìˆ˜ì§‘
"""

import asyncio
import json
import time
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# =============================================================================
# ê¸°ë³¸ ë°ì´í„° êµ¬ì¡°
# =============================================================================

class AttackType(Enum):
    RECONNAISSANCE = "reconnaissance"
    PROTOCOL_TAMPERING = "protocol_tampering"
    INJECTION = "injection"
    DOS = "denial_of_service"
    EXFILTRATION = "exfiltration"

class AttackStatus(Enum):
    SUCCESS = "success"
    FAILED = "failed"
    DETECTED = "detected"

@dataclass
class AttackResult:
    attack_id: str
    attack_name: str
    attack_type: AttackType
    status: AttackStatus
    success_rate: float
    response_time: float
    timestamp: float
    target: str
    iocs: List[str]
    details: Dict[str, Any]
    
    @property
    def success(self) -> bool:
        """í˜¸í™˜ì„±ì„ ìœ„í•œ success í”„ë¡œí¼í‹°"""
        return self.status == AttackStatus.SUCCESS
    
    @property
    def execution_time(self) -> float:
        """í˜¸í™˜ì„±ì„ ìœ„í•œ execution_time í”„ë¡œí¼í‹°"""
        return self.response_time
    
    @property
    def error_message(self) -> Optional[str]:
        """í˜¸í™˜ì„±ì„ ìœ„í•œ error_message í”„ë¡œí¼í‹°"""
        return self.details.get("error")

# =============================================================================
# DVD-Lite ë©”ì¸ í´ë˜ìŠ¤
# =============================================================================

class DVDLite:
    """ê²½ëŸ‰í™”ëœ DVD í…ŒìŠ¤íŠ¸ë² ë“œ"""
    
    def __init__(self, config_path: str = "config.json"):
        self.config = self._load_config(config_path)
        self.attack_modules = {}
        self.results = []
        self.cti_collector = None
        
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            logger.warning(f"ì„¤ì • íŒŒì¼ {config_path}ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ì„¤ì •ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.")
            return self._default_config()
    
    def _default_config(self) -> Dict[str, Any]:
        """ê¸°ë³¸ ì„¤ì •"""
        return {
            "target": {"ip": "10.13.0.2", "mavlink_port": 14550},
            "attacks": {"enabled": [], "delay_between": 2.0},
            "cti": {"auto_collect": True, "export_format": "json"},
            "output": {"results_dir": "results", "log_level": "INFO"}
        }
    
    def register_attack(self, name: str, attack_class):
        """ê³µê²© ëª¨ë“ˆ ë“±ë¡"""
        self.attack_modules[name] = attack_class
        logger.info(f"âœ… ê³µê²© ëª¨ë“ˆ ë“±ë¡: {name}")
    
    def register_cti_collector(self, cti_collector):
        """CTI ìˆ˜ì§‘ê¸° ë“±ë¡"""
        self.cti_collector = cti_collector
        logger.info("âœ… CTI ìˆ˜ì§‘ê¸° ë“±ë¡ ì™„ë£Œ")
    
    def list_attacks(self) -> List[str]:
        """ë“±ë¡ëœ ê³µê²© ëª©ë¡ ë°˜í™˜"""
        return list(self.attack_modules.keys())
    
    def get_attack_info(self, attack_name: str) -> Dict[str, Any]:
        """ê³µê²© ì •ë³´ ë°˜í™˜"""
        attack_class = self.attack_modules.get(attack_name)
        if not attack_class:
            return {}
        
        return {
            "name": attack_name,
            "class": attack_class.__name__,
            "docstring": attack_class.__doc__ or "",
            "type": getattr(attack_class, '_get_attack_type', lambda: AttackType.RECONNAISSANCE)().value
        }
    
    async def run_attack(self, attack_name: str, **kwargs) -> AttackResult:
        """ë‹¨ì¼ ê³µê²© ì‹¤í–‰"""
        if attack_name not in self.attack_modules:
            raise ValueError(f"ê³µê²© ëª¨ë“ˆ '{attack_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        
        # ê³µê²© ëª¨ë“ˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        attack_class = self.attack_modules[attack_name]
        attack_instance = attack_class(
            target_ip=self.config["target"]["ip"],
            **kwargs
        )
        
        # ê³µê²© ì‹¤í–‰
        result = await attack_instance.execute()
        self.results.append(result)
        
        # CTI ìˆ˜ì§‘
        if self.cti_collector and self.config["cti"]["auto_collect"]:
            await self.cti_collector.collect_from_result(result)
        
        return result
    
    async def run_multiple_attacks(self, attack_names: List[str]) -> List[AttackResult]:
        """ì—¬ëŸ¬ ê³µê²© ì‹¤í–‰"""
        results = []
        
        for attack_name in attack_names:
            try:
                result = await self.run_attack(attack_name)
                results.append(result)
                
                # ê³µê²© ê°„ ì§€ì—°
                await asyncio.sleep(self.config["attacks"]["delay_between"])
                
            except Exception as e:
                logger.error(f"ê³µê²© {attack_name} ì‹¤íŒ¨: {str(e)}")
        
        return results
    
    async def run_campaign(self, attack_names: List[str] = None) -> List[AttackResult]:
        """ê³µê²© ìº í˜ì¸ ì‹¤í–‰"""
        if attack_names is None:
            attack_names = self.config["attacks"]["enabled"]
        
        logger.info(f"ğŸš€ ê³µê²© ìº í˜ì¸ ì‹œì‘: {len(attack_names)}ê°œ ê³µê²©")
        results = []
        
        for i, attack_name in enumerate(attack_names, 1):
            logger.info(f"ê³µê²© {i}/{len(attack_names)}: {attack_name}")
            
            try:
                result = await self.run_attack(attack_name)
                results.append(result)
                
                # ê³µê²© ê°„ ëŒ€ê¸°
                if i < len(attack_names):
                    await asyncio.sleep(self.config["attacks"]["delay_between"])
                    
            except Exception as e:
                logger.error(f"ê³µê²© {attack_name} ì‹¤íŒ¨: {str(e)}")
        
        logger.info(f"âœ… ìº í˜ì¸ ì™„ë£Œ: {len(results)}ê°œ ê³µê²© ì‹¤í–‰")
        return results
    
    def get_summary(self) -> Dict[str, Any]:
        """ê²°ê³¼ ìš”ì•½"""
        if not self.results:
            return {"message": "ì‹¤í–‰ëœ ê³µê²©ì´ ì—†ìŠµë‹ˆë‹¤."}
        
        total = len(self.results)
        successful = sum(1 for r in self.results if r.status == AttackStatus.SUCCESS)
        detected = sum(1 for r in self.results if r.status == AttackStatus.DETECTED)
        
        return {
            "total_attacks": total,
            "successful_attacks": successful,
            "detected_attacks": detected,
            "success_rate": f"{(successful/total)*100:.1f}%",
            "detection_rate": f"{(detected/total)*100:.1f}%",
            "avg_response_time": f"{sum(r.response_time for r in self.results)/total:.2f}s"
        }
    
    def export_results(self, filename: str = None) -> str:
        """ê²°ê³¼ ë‚´ë³´ë‚´ê¸°"""
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"results/dvd_lite_results_{timestamp}.json"
        
        # ê²°ê³¼ ë””ë ‰í† ë¦¬ ìƒì„±
        Path(filename).parent.mkdir(parents=True, exist_ok=True)
        
        # ê²°ê³¼ ë°ì´í„° êµ¬ì„±
        export_data = {
            "metadata": {
                "timestamp": datetime.now().isoformat(),
                "config": self.config,
                "summary": self.get_summary()
            },
            "results": [asdict(result) for result in self.results]
        }
        
        # JSON íŒŒì¼ë¡œ ì €ì¥
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)
        
        logger.info(f"ğŸ“„ ê²°ê³¼ ì €ì¥: {filename}")
        return filename
    
    def print_summary(self):
        """ê²°ê³¼ ìš”ì•½ ì¶œë ¥"""
        summary = self.get_summary()
        
        print("\\n" + "="*50)
        print("ğŸ¯ DVD-Lite ì‹¤í–‰ ê²°ê³¼ ìš”ì•½")
        print("="*50)
        
        if "message" in summary:
            print(summary["message"])
        else:
            print(f"ì´ ê³µê²© ìˆ˜: {summary['total_attacks']}")
            print(f"ì„±ê³µí•œ ê³µê²©: {summary['successful_attacks']} ({summary['success_rate']})")
            print(f"íƒì§€ëœ ê³µê²©: {summary['detected_attacks']} ({summary['detection_rate']})")
            print(f"í‰ê·  ì‘ë‹µ ì‹œê°„: {summary['avg_response_time']}")
        
        print("="*50)
        
        # ê°œë³„ ê²°ê³¼ ì¶œë ¥
        if self.results:
            print("\\nğŸ“‹ ê°œë³„ ê³µê²© ê²°ê³¼:")
            for i, result in enumerate(self.results, 1):
                status_icon = "âœ…" if result.status == AttackStatus.SUCCESS else "âŒ"
                print(f"{i}. {result.attack_name}: {status_icon} {result.status.value}")
                print(f"   ì‹œê°„: {result.response_time:.2f}s, IOC: {len(result.iocs)}ê°œ")

# =============================================================================
# ê¸°ë³¸ ê³µê²© ë² ì´ìŠ¤ í´ë˜ìŠ¤
# =============================================================================

class BaseAttack:
    """ê³µê²© ê¸°ë³¸ í´ë˜ìŠ¤"""
    
    def __init__(self, target_ip: str = "10.13.0.2", **kwargs):
        self.target_ip = target_ip
        self.config = kwargs
        self.attack_id = f"{self.__class__.__name__.lower()}_{int(time.time())}"
    
    async def execute(self) -> AttackResult:
        """ê³µê²© ì‹¤í–‰"""
        start_time = time.time()
        
        try:
            # ì‹¤ì œ ê³µê²© ë¡œì§ ì‹¤í–‰
            success, iocs, details = await self._run_attack()
            
            # ê²°ê³¼ ìƒì„±
            result = AttackResult(
                attack_id=self.attack_id,
                attack_name=self.__class__.__name__,
                attack_type=self._get_attack_type(),
                status=AttackStatus.SUCCESS if success else AttackStatus.FAILED,
                success_rate=details.get("success_rate", 0.7 if success else 0.0),
                response_time=time.time() - start_time,
                timestamp=time.time(),
                target=self.target_ip,
                iocs=iocs,
                details=details
            )
            
            return result
            
        except Exception as e:
            return AttackResult(
                attack_id=self.attack_id,
                attack_name=self.__class__.__name__,
                attack_type=self._get_attack_type(),
                status=AttackStatus.FAILED,
                success_rate=0.0,
                response_time=time.time() - start_time,
                timestamp=time.time(),
                target=self.target_ip,
                iocs=[],
                details={"error": str(e)}
            )
    
    async def _run_attack(self) -> tuple:
        """ì‹¤ì œ ê³µê²© ë¡œì§ - í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„"""
        raise NotImplementedError
    
    def _get_attack_type(self) -> AttackType:
        """ê³µê²© íƒ€ì… ë°˜í™˜ - í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„"""
        raise NotImplementedError
'''
    
    file_path = Path("dvd_lite/main.py")
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"âœ… ì—…ë°ì´íŠ¸: {file_path}")

def create_component_modules():
    """ì»´í¬ë„ŒíŠ¸ ëª¨ë“ˆë“¤ ìƒì„±"""
    
    # 1. í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ìƒì„±
    create_core_modules()
    
    # 2. ê³µê²© ëª¨ë“ˆ ìƒì„±
    create_attack_modules()
    
    # 3. ë ˆì§€ìŠ¤íŠ¸ë¦¬ ëª¨ë“ˆ ìƒì„±
    create_registry_modules()

def create_core_modules():
    """í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ëª¨ë“ˆ ìƒì„±"""
    
    # enums.py
    enums_content = '''# dvd_lite/dvd_attacks/core/enums.py
"""
DVD ê³µê²© ì‹œìŠ¤í…œ ì—´ê±°í˜• ì •ì˜
"""
from enum import Enum

class AttackType(Enum):
    """ê³µê²© ìœ í˜•"""
    RECONNAISSANCE = "reconnaissance"
    PROTOCOL_TAMPERING = "protocol_tampering"
    DOS = "denial_of_service"
    INJECTION = "injection"
    EXFILTRATION = "exfiltration"
    FIRMWARE_ATTACKS = "firmware_attacks"

class DVDAttackTactic(Enum):
    """DVD ê³µê²© ì „ìˆ  ë¶„ë¥˜"""
    RECONNAISSANCE = "reconnaissance"
    PROTOCOL_TAMPERING = "protocol_tampering"
    DENIAL_OF_SERVICE = "denial_of_service"
    INJECTION = "injection"
    EXFILTRATION = "exfiltration"
    FIRMWARE_ATTACKS = "firmware_attacks"

class DVDFlightState(Enum):
    """ë“œë¡  ë¹„í–‰ ìƒíƒœ"""
    PRE_FLIGHT = "pre_flight"
    TAKEOFF = "takeoff"
    AUTOPILOT_FLIGHT = "autopilot_flight"
    MANUAL_FLIGHT = "manual_flight"
    EMERGENCY_RTL = "emergency_rtl"
    POST_FLIGHT = "post_flight"

class AttackDifficulty(Enum):
    """ê³µê²© ë‚œì´ë„"""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"

class AttackStatus(Enum):
    """ê³µê²© ìƒíƒœ"""
    SUCCESS = "success"
    FAILED = "failed"
    DETECTED = "detected"
    PARTIAL = "partial"
'''
    
    Path("dvd_lite/dvd_attacks/core/enums.py").write_text(enums_content, encoding='utf-8')
    print("âœ… ìƒì„±: dvd_lite/dvd_attacks/core/enums.py")
    
    # scenario.py
    scenario_content = '''# dvd_lite/dvd_attacks/core/scenario.py
"""
DVD ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ ì •ì˜
"""
from dataclasses import dataclass
from typing import List
from .enums import DVDAttackTactic, DVDFlightState, AttackDifficulty

@dataclass
class DVDAttackScenario:
    """DVD ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ ì •ì˜"""
    name: str
    tactic: DVDAttackTactic
    description: str
    required_states: List[DVDFlightState]
    difficulty: AttackDifficulty
    prerequisites: List[str]
    targets: List[str]
    estimated_duration: float = 0.0
    stealth_level: str = "medium"
    impact_level: str = "medium"
'''
    
    Path("dvd_lite/dvd_attacks/core/scenario.py").write_text(scenario_content, encoding='utf-8')
    print("âœ… ìƒì„±: dvd_lite/dvd_attacks/core/scenario.py")
    
    # attack_base.py
    attack_base_content = '''# dvd_lite/dvd_attacks/core/attack_base.py
"""
ê³µê²© ê¸°ë³¸ í´ë˜ìŠ¤ ì •ì˜
"""
import asyncio
import time
import logging
from abc import ABC, abstractmethod
from typing import Tuple, List, Dict, Any, Optional
from dataclasses import dataclass
from .enums import AttackType, AttackStatus

logger = logging.getLogger(__name__)

@dataclass
class AttackResult:
    """ê³µê²© ê²°ê³¼ ë°ì´í„° í´ë˜ìŠ¤"""
    attack_id: str
    attack_name: str
    attack_type: AttackType
    status: AttackStatus
    success_rate: float
    response_time: float
    timestamp: float
    target: str
    iocs: List[str]
    details: Dict[str, Any]
    scenario_info: Optional[Dict[str, Any]] = None

class BaseAttack(ABC):
    """DVD ê³µê²© ê¸°ë³¸ í´ë˜ìŠ¤"""
    
    def __init__(self, target_ip: str = "10.13.0.2", **kwargs):
        self.target_ip = target_ip
        self.config = kwargs
        self.attack_id = f"{self.__class__.__name__.lower()}_{int(time.time())}"
        self.logger = logging.getLogger(f"attack.{self.__class__.__name__}")
    
    async def execute(self) -> AttackResult:
        """ê³µê²© ì‹¤í–‰ ë©”ì¸ ë©”ì„œë“œ"""
        start_time = time.time()
        self.logger.info(f"ê³µê²© ì‹œì‘: {self.__class__.__name__} -> {self.target_ip}")
        
        try:
            success, iocs, details = await self._run_attack()
            
            result = AttackResult(
                attack_id=self.attack_id,
                attack_name=self.__class__.__name__,
                attack_type=self._get_attack_type(),
                status=AttackStatus.SUCCESS if success else AttackStatus.FAILED,
                success_rate=details.get("success_rate", 0.7 if success else 0.0),
                response_time=time.time() - start_time,
                timestamp=time.time(),
                target=self.target_ip,
                iocs=iocs,
                details=details
            )
            
            self.logger.info(f"ê³µê²© ì™„ë£Œ: {result.status.value} ({result.response_time:.2f}ì´ˆ)")
            return result
            
        except Exception as e:
            self.logger.error(f"ê³µê²© ì‹¤íŒ¨: {str(e)}")
            return AttackResult(
                attack_id=self.attack_id,
                attack_name=self.__class__.__name__,
                attack_type=self._get_attack_type(),
                status=AttackStatus.FAILED,
                success_rate=0.0,
                response_time=time.time() - start_time,
                timestamp=time.time(),
                target=self.target_ip,
                iocs=[],
                details={"error": str(e)}
            )
    
    @abstractmethod
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ì‹¤ì œ ê³µê²© ë¡œì§ - í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ë°˜ë“œì‹œ êµ¬í˜„"""
        pass
    
    @abstractmethod
    def _get_attack_type(self) -> AttackType:
        """ê³µê²© íƒ€ì… ë°˜í™˜ - í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ë°˜ë“œì‹œ êµ¬í˜„"""
        pass
'''
    
    Path("dvd_lite/dvd_attacks/core/attack_base.py").write_text(attack_base_content, encoding='utf-8')
    print("âœ… ìƒì„±: dvd_lite/dvd_attacks/core/attack_base.py")

def create_attack_modules():
    """ê³µê²© ëª¨ë“ˆë“¤ ìƒì„±"""
    
    # ê° ê³µê²© ì¹´í…Œê³ ë¦¬ë³„ë¡œ ê¸°ë³¸ ëª¨ë“ˆ ìƒì„±
    categories = [
        "reconnaissance", "protocol_tampering", "denial_of_service", 
        "injection", "exfiltration", "firmware_attacks"
    ]
    
    for category in categories:
        # ê¸°ë³¸ ê³µê²© ëª¨ë“ˆ ìƒì„± (ê°„ë‹¨í•œ ì˜ˆì‹œ)
        if category == "reconnaissance":
            create_reconnaissance_modules()
        elif category == "protocol_tampering":
            create_protocol_tampering_modules()
        # ë‹¤ë¥¸ ì¹´í…Œê³ ë¦¬ë“¤ì€ ê¸°ë³¸ íŒŒì¼ë§Œ ìƒì„±
        else:
            create_basic_category_file(category)

def create_reconnaissance_modules():
    """ì •ì°° ëª¨ë“ˆ ìƒì„±"""
    
    # wifi_discovery.py
    wifi_content = '''# dvd_lite/dvd_attacks/reconnaissance/wifi_discovery.py
"""
WiFi ë„¤íŠ¸ì›Œí¬ ë°œê²¬ ê³µê²©
"""
import asyncio
import random
from typing import Tuple, List, Dict, Any
from ..core.attack_base import BaseAttack
from ..core.enums import AttackType

class WiFiNetworkDiscovery(BaseAttack):
    """WiFi ë„¤íŠ¸ì›Œí¬ ë°œê²¬ ë° ì—´ê±°"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.RECONNAISSANCE
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """WiFi ë„¤íŠ¸ì›Œí¬ ìŠ¤ìº” ë° ë“œë¡  ë„¤íŠ¸ì›Œí¬ ì‹ë³„"""
        await asyncio.sleep(2.5)
        
        networks = [
            {"ssid": "Drone_WiFi", "bssid": "aa:bb:cc:dd:ee:01", "encryption": "WPA2"},
            {"ssid": "DJI_MAVIC_123456", "bssid": "aa:bb:cc:dd:ee:02", "encryption": "WPA"},
            {"ssid": "ArduPilot_AP", "bssid": "aa:bb:cc:dd:ee:03", "encryption": "Open"},
        ]
        
        discovered = random.sample(networks, k=random.randint(1, 3))
        
        iocs = []
        for network in discovered:
            iocs.append(f"WIFI_SSID:{network['ssid']}")
            iocs.append(f"WIFI_BSSID:{network['bssid']}")
        
        success = len(discovered) > 0
        
        details = {
            "discovered_networks": discovered,
            "scan_method": "passive_monitor",
            "success_rate": 0.85 if success else 0.3
        }
        
        return success, iocs, details
'''
    
    Path("dvd_lite/dvd_attacks/reconnaissance/wifi_discovery.py").write_text(wifi_content, encoding='utf-8')
    print("âœ… ìƒì„±: dvd_lite/dvd_attacks/reconnaissance/wifi_discovery.py")
    
    # mavlink_discovery.py
    mavlink_content = '''# dvd_lite/dvd_attacks/reconnaissance/mavlink_discovery.py
"""
MAVLink ì„œë¹„ìŠ¤ ë°œê²¬ ê³µê²©
"""
import asyncio
import random
from typing import Tuple, List, Dict, Any
from ..core.attack_base import BaseAttack
from ..core.enums import AttackType

class MAVLinkServiceDiscovery(BaseAttack):
    """MAVLink ì„œë¹„ìŠ¤ ë°œê²¬ ë° ì—´ê±°"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.RECONNAISSANCE
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ë„¤íŠ¸ì›Œí¬ì—ì„œ MAVLink ì„œë¹„ìŠ¤ ìŠ¤ìº”"""
        await asyncio.sleep(3.2)
        
        services = []
        hosts = [f"192.168.13.{i}" for i in range(1, 11)]
        
        for host in hosts:
            if random.random() > 0.7:
                service = {
                    "host": host,
                    "port": random.choice([14550, 14551, 5760]),
                    "service": "MAVLink"
                }
                services.append(service)
        
        iocs = [f"MAVLINK_SERVICE:{s['host']}:{s['port']}" for s in services]
        success = len(services) > 0
        
        details = {
            "discovered_services": services,
            "scan_method": "port_scan",
            "success_rate": 0.75 if success else 0.1
        }
        
        return success, iocs, details
'''
    
    Path("dvd_lite/dvd_attacks/reconnaissance/mavlink_discovery.py").write_text(mavlink_content, encoding='utf-8')
    print("âœ… ìƒì„±: dvd_lite/dvd_attacks/reconnaissance/mavlink_discovery.py")

def create_protocol_tampering_modules():
    """í”„ë¡œí† ì½œ ë³€ì¡° ëª¨ë“ˆ ìƒì„±"""
    
    # GPS ìŠ¤í‘¸í•‘ì€ ì´ë¯¸ ì¡´ì¬í•˜ë¯€ë¡œ ê±´ë„ˆë›°ê¸°
    pass

def create_basic_category_file(category: str):
    """ê¸°ë³¸ ì¹´í…Œê³ ë¦¬ íŒŒì¼ ìƒì„±"""
    
    content = f'''# dvd_lite/dvd_attacks/{category}/basic.py
"""
{category} ê¸°ë³¸ ê³µê²© ëª¨ë“ˆ
"""
import asyncio
import random
from typing import Tuple, List, Dict, Any
from ..core.attack_base import BaseAttack
from ..core.enums import AttackType

class BasicAttack(BaseAttack):
    """ê¸°ë³¸ ê³µê²© í´ë˜ìŠ¤"""
    
    def _get_attack_type(self) -> AttackType:
        return AttackType.RECONNAISSANCE  # ê¸°ë³¸ê°’
    
    async def _run_attack(self) -> Tuple[bool, List[str], Dict[str, Any]]:
        """ê¸°ë³¸ ê³µê²© ë¡œì§"""
        await asyncio.sleep(2.0)
        
        success = random.random() > 0.5
        iocs = [f"BASIC_IOC:test_indicator"]
        details = {{"success_rate": 0.5}}
        
        return success, iocs, details
'''
    
    Path(f"dvd_lite/dvd_attacks/{category}/basic.py").write_text(content, encoding='utf-8')
    print(f"âœ… ìƒì„±: dvd_lite/dvd_attacks/{category}/basic.py")

def create_registry_modules():
    """ë ˆì§€ìŠ¤íŠ¸ë¦¬ ëª¨ë“ˆ ìƒì„±"""
    
    # management.py
    management_content = '''# dvd_lite/dvd_attacks/registry/management.py
"""
DVD ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ í†µí•© ê´€ë¦¬
"""
import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

# ê¸°ë³¸ ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ ë“±ë¡
def register_all_dvd_attacks():
    """ëª¨ë“  DVD ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ ë“±ë¡"""
    registered_attacks = []
    
    # ê¸°ë³¸ ê³µê²©ë“¤ ë“±ë¡
    basic_attacks = [
        "wifi_network_discovery",
        "mavlink_service_discovery",
        "gps_spoofing",
        "telemetry_exfiltration"
    ]
    
    for attack in basic_attacks:
        registered_attacks.append(attack)
    
    logger.info(f"âœ… {len(registered_attacks)}ê°œ ê³µê²© ë“±ë¡ ì™„ë£Œ")
    return registered_attacks

def get_attacks_by_tactic(tactic) -> List[str]:
    """ì „ìˆ ë³„ ê³µê²© ëª©ë¡ ë°˜í™˜"""
    # ê¸°ë³¸ êµ¬í˜„
    return ["wifi_network_discovery", "mavlink_service_discovery"]

def get_attacks_by_difficulty(difficulty) -> List[str]:
    """ë‚œì´ë„ë³„ ê³µê²© ëª©ë¡ ë°˜í™˜"""
    # ê¸°ë³¸ êµ¬í˜„
    return ["wifi_network_discovery"]

def get_attacks_by_flight_state(state) -> List[str]:
    """ë¹„í–‰ ìƒíƒœë³„ ê³µê²© ëª©ë¡ ë°˜í™˜"""
    # ê¸°ë³¸ êµ¬í˜„
    return ["wifi_network_discovery"]

def get_attack_info(attack_name: str) -> Dict[str, Any]:
    """ê³µê²© ì •ë³´ ë°˜í™˜"""
    # ê¸°ë³¸ êµ¬í˜„
    return {
        "name": attack_name,
        "description": f"{attack_name} ê³µê²©",
        "difficulty": "beginner",
        "tactic": "reconnaissance",
        "targets": ["network"],
        "estimated_duration": 2.5,
        "stealth_level": "medium",
        "impact_level": "low"
    }
'''
    
    Path("dvd_lite/dvd_attacks/registry/management.py").write_text(management_content, encoding='utf-8')
    print("âœ… ìƒì„±: dvd_lite/dvd_attacks/registry/management.py")

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("ğŸ”§ ëˆ„ë½ëœ í•µì‹¬ ëª¨ë“ˆ ìƒì„± ì¤‘...")
    print("=" * 50)
    
    # 1. CTI ëª¨ë“ˆ ìƒì„±
    create_cti_module()
    
    # 2. ê¸°ë³¸ attacks ëª¨ë“ˆ ìƒì„±
    create_attacks_module()
    
    # 3. ë©”ì¸ ëª¨ë“ˆ ì—…ë°ì´íŠ¸
    create_main_module()
    
    # 4. ì»´í¬ë„ŒíŠ¸ ëª¨ë“ˆë“¤ ìƒì„±
    create_component_modules()
    
    print("\n" + "=" * 50)
    print("ğŸ‰ ëª¨ë“  í•µì‹¬ ëª¨ë“ˆì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!")
    print("\nğŸš€ ì´ì œ ë‹¤ìŒ ëª…ë ¹ì„ ì‹¤í–‰í•´ë³´ì„¸ìš”:")
    print("   python3 advanced_start.py")
    print("   ë˜ëŠ”")
    print("   python3 quick_start.py")

if __name__ == "__main__":
    main()